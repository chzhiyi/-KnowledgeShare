# B+树
InnoDB中，表是根据主键顺序以索引的形式存放的，这种存储方式的表叫索引组织表。
InnoDB使用B+树索引模型，所以数据是存储在B+树中。
每个索引在InnoDB里面对应一颗B+树。

# 建表
	create table T (
		ID int primary key,
		k int not null default 0,
		s varchar(16) not null default '',
		index k(k)
	)engine=InnoDB DEFAULT CHARSET=utf8;
# 插数据
	insert into T values(100,1,'AA'),(200,2,'bb'),(300,3,'cc'),(400,4,'dd'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
# 查询数据
	mysql> select * from t;
	+-----+---+----+
	| ID  | k | s  |
	+-----+---+----+
	| 100 | 1 | AA |
	| 200 | 2 | bb |
	| 300 | 3 | cc |
	| 400 | 4 | dd |
	| 500 | 5 | ee |
	| 600 | 6 | ff |
	| 700 | 7 | gg |
	+-----+---+----+
	7 rows in set (0.00 sec)
# 修改表的默认字符集
	alter table t default character set utf8;

# 基于主键索引和普通索引的查询有什么区别？
	mysql> explain select * from t where id=500;
		+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
		| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
		+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
		|  1 | SIMPLE      | t     | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
		+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
		1 row in set, 1 warning (0.01 sec)
	mysql> explain select * from t where k=5;
		+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
		| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra |
		+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
		|  1 | SIMPLE      | t     | NULL       | ref  | k             | k    | 4       | const |    1 |   100.00 | NULL  |
		+----+-------------+-------+------------+------+---------------+------+---------+-------+------+----------+-------+
		1 row in set, 1 warning (0.00 sec)
# 自增主键
	not null primary key auto_increment
	性能：自增主键，插入新记录时，都是追加操作，不涉及挪动其它记录。
		 业务逻辑字段做主键，不容易保证有序插入，写数据成本较高。
    存储空间：用业务逻辑字段如身份证号做主键，还是用自增字段做主键？
    	 非主键索引，其叶子节点都是主键的值。身份证号做主键，叶子节点占用约18字节；如果用整型做主键，只需要4个字节，长整型bigint则需要8个字节。
    	 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间就越小。

# 覆盖索引                      
	select * from T where k between 3 and 5;
	mysql> explain select * from t where k between 3 and 5;
		+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
		| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
		+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
		|  1 | SIMPLE      | t     | NULL       | ALL  | k             | NULL | NULL    | NULL |    7 |    42.86 | Using where |
		+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
		1 row in set, 1 warning (0.00 sec)
	mysql> explain select id from t where k between 3 and 5;
		+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
		| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                    |
		+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
		|  1 | SIMPLE      | t     | NULL       | range | k             | k    | 4       | NULL |    3 |   100.00 | Using where; Using index |
		+----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
		1 row in set, 1 warning (0.01 sec)

# 最左前缀原则
1联合索引的最左N个字段；2字符串索引的最左M个字符。
# 索引下推
在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
